# MD5_Message_Digest_Algorithm
4th Year semester 2 project for the Theory of Algorithms module. This project is coded on a Google Cloud Virtual Machine (Linux Debian 10). The project is also coded using VI as an editor.
 
## Introduction
This document includes an overview of the MD5 algorithm and its computation in C. This will look into areas such as how it's run, tested and the algorithm complexity as some examples of topics covered below.
 
### Project Statement
Write a program in the C programming language that calculates the MD5 hash digest of an input. The algorithm is speciﬁed in the Request for Comments 1321 document supplied by the Internet Engineering Task Force. The only prerequisite is that your program performs the algorithm — you are free to decide what input the algorithm should be performed on. It is suggested you allow the user to input some free text or a ﬁlename via the command line.
 
### Repository Introduction
The repository on GitHub was used in order to keep track of progress throughout development. The repository contains a readme which describes the project and how it was carried out. The sections include a how to run section specifying how a user would go about downloading and running the project on their own computer. It also has a section which details how the algorithm works and a research and project progress summary which details the work that has gone into the project as well as research gone into the project throughout the development lifecycle. The repository also contains a gitignore. This is used to prevent unnecessary files from being uploaded to the GitHub repository. This was used to prevent executable files that were compiled from being uploaded to the project throughout. This included test file executables as well as the actual md5 algorithm implementation file executables. The final thing in the repository is the actual c file which contains the implementation of the md5 hashing algorithm. 
 
### Code Overview
This code uses the md5 hashing algorithm to hash an input using a set of options available to the user. The user has the option to hash a string they input. This can be done by running the executable in the command line followed by the --string option and then after specifying the string they wish to hash. An example input would be “MD5.exe --string abc“. This would hash the string “abc” using the md5 algorithm to produce an output. The user also has an option to hash a file’s contents using the algorithm. This is done by using the --file parameter option after the executable followed by the name of the file you wish to have its contents hashed. An example of command line input would be “MD5.exe --file filename.txt “. The last input which involves using the algorithm is the testing suite option. This is done by following the executable file with the --test parameter option. This is run using the following parameter in the command line “MD5.exe --test”. This runs a set of test cases which are outlined in the MD5 documentation to ensure that the algorithm carries out the hashing process correctly. 
 
## Running the code
The first step to running the code is to either download or clone the repository from github. This can be done via the command line using “git clone” followed by the repository link or by pressing the download button on GitHub and unzipping the zip file into your desired directory. The next step is to compile the code. This includes opening a terminal in the directory of the cloned/downloaded project, then running the command “gcc -o MD5 md5.c” where MD5 is the name which will be given to your executable file. This executable file can be run in a command terminal by entering the name of the executable or the name of the executable followed by .exe i.e. “MD5” or “MD5.exe”. The parameters mentioned above in the code overview section can then be used to run the application. There is also an additional --help parameter option which displays the options to the user and samples of how to run each.
 
## Testing
Testing is carried out as specified in the above sections by running the --test parameter option in the command line. This uses the selection of test cases given in the [RFC document](https://tools.ietf.org/html/rfc1321) in section A.5, page 21. This automatically runs all these tests by hashing them and displaying the hashing algorithms results. As stated in the code section above the command line input for executing these tests is “MD5.exe --test” where MD5 is the executable name.

## Algorithm
This section details an overview of the MD5 algorithm and gives an explanation of its implementation within my code. The first part of the explanation will give a brief overview of the algorithm before going into specific details about the implementation. MD5 hashing is an algorithm which is used to produce a 128-bit message digest. A text of 512-bit blocks is divided into 16 blocks. Each of these 16-bit blocks consist of 32 bits. This results in a 128-bit message digest made up of 4 32-bit blocks.

In my algorithm, I chose that I would try to do the algorithm without the use of external libraries besides the library used for input and output (stdio.h). This was to reduce the reliance of my algorithm on external libraries which would do many parts of the implementation for me were they to be used. Throughout this explanation I will provide reasoning for the choices made in my implementation. 

The first part of the algorithm implementation includes the creation of the auxiliary functions. These functions are used during the transformation rounds later in the algorithm. These include functions for F, G, H and I. These functions use logical operators like OR, XOR, NOR to produce an output. There are also four functions FF,GG,HH and II which use the previously defined F,G,H and I as well as taking a block and constants given in the [RFC document](https://tools.ietf.org/html/rfc1321). There are also many constants defined which are used throughout the code which are defined at the beginning in order to give the code a clean look e.g Padding and constants used in the transformation rounds which will be explained later. The constants are located in the [RFC document](https://tools.ietf.org/html/rfc1321) in section A.3.

The next part of the algorithm is the MD5 context. This contains the states, number of bits, modulo 2^64 (count) as well as the input buffer. These are all specified again in the [RFC document](https://tools.ietf.org/html/rfc1321). I also add the final digest value to this context as it is what is used to carry out the process of the MD5 algorithm, I felt this would be the best place to put it, rather than have a created variable which would just store the result outside of the algorithm as displayed in the RFC Document. This context is defined as a struct and is used in the initialisation of the MD5 algorithm. A variable of this is created at the very beginning of the MD5 hashing process.

The next section in the algorithm is the MD5 initialisation method. This is used to set up all the variables which need initialisation in the previously defined MD5 context struct. This initialises the counts of the context to 0. It also loads magic initialization constants into the state values. These values are stated in the [RFC document](https://tools.ietf.org/html/rfc1321) in section A.3 page 11. This method is called at the very beginning of the process and is given a pointer value to the context variable created in the previous section whose values are updated.

The next stage defined in my algorithm is the MD5 transform method. This is the method which is used to carry out transformations on the states of the context. This method takes in 2 parameters for a state and a block. Each of the 4 states within the state pointer are assigned to a, b, c and d respectively. These 4 states along with the block are then put through a series of 4 rounds. This uses the FF function in the first round and runs for 16 iterations. Each iteration includes a block input (starting at block [0] and running to block [15] - 16 operations on the block). The states a, b, c and d are also used in the transformations and are placed in different orders in the FF method as displayed in the [RFC document](https://tools.ietf.org/html/rfc1321) under section A.3 pages 13 and 14. Another 16 rounds are carried out for the GG, HH and II  functions using the different constants and different ordering of the blocks though the ordering of a, b, c and d are the same for all 4 rounds. The states are then updated with a, b, c and d after all rounds have been completed. This method is called inside both the update and final MD5 methods.

The next method defined is the MD5 update method. This method continues an MD5 message-digest operation, processing another message block, and updating the context. The method takes in a pointer to the md5 context, an input block and the length of that input block. The first thing the method does is compute the number of bytes mod 64 to compute an index. Then the bits are updated, that is the context’s count values are updated using the input length as well as right and left bit shifting. While the input length decrements down to zero, a process takes place within this while loop. The buffer value in the context is updated and the index is incremented. Before the transform is called I populate the blocks by looping over them, this process can be seen in the decoding section of the [RFC document](https://tools.ietf.org/html/rfc1321). This process is carried out in the document during the transform method. This includes the shifting of bits which populate into each bit of a 16-bit block, I incorporated it here before the transform method is called. I chose this as a design decision as I like to keep methods using the single responsibility principle design architecture. This also allowed me to change up the code structure in comparison with the code given in the RFC document. Prior to this, the MD5 transform method mentioned above is called using the context state and the 16-bit block just populated.

The last method which is used to carry out a part in the process of calculating the MD5 hash is the MD5 final method. This method is used to calculate the final digest and ends an MD5 message-digest operation. The final method takes a pointer to the context as a parameter. The first operation that is carried out is assigning the last 2 bits of a 16-bit block to the values stored in the contexts count (i.e it’s number of bits). The next step involves a padding process to 56 modules 64. This process involves creating an index which is used to calculate the padding length, when this is calculated the MD5 update method is called using the context, padding constant initialised at the beginning of the algorithm and the padding length just calculated. The rest of the block (14 bits) is then populated (i.e the last 2 blocks have already been populated from the first part of the method). Then the same encoding as mentioned in the update is used here also before calling the transform method with the context and block (same as update’s call to transform method). Finally, the final value of the digest is then calculated. It was at this point I decided to put the final digest value into the context for convenience.  This value can then be accessed by the context at any time (e.g. for printing result).
